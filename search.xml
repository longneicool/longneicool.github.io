<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Chap7 进程环境]]></title>
    <url>%2F2018%2F09%2F29%2Fchap7-process%2F</url>
    <content type="text"><![CDATA[7.3 进程终止1 退出函数123456#include &lt;stdlib.h&gt;void exit(int status)void _Exit(int status);#include &lt;unistd.h&gt;void _exit(int status); 如上, _Exit 与 _exit是等价的，其exit的区别是： _exit 与 _Exit直接进入内核 exit先执行一些清理工作，然后再进入内核。exit函数在执行时总是会清理关闭标准I/O库，会将缓冲区的数据输出到文件 1234567// exit// 输出Hello Worldint main(int argc, char** argv)&#123; printf("Hello World"); exit(0);&#125; 123456// _exit: 无输出int main(int argc, char** argv)&#123; printf("Hello World"); _exit(0);&#125; 在stdlib.h中，对exit的定义为 1234/* Call all functions registered with `atexit' and `on_exit', in the reverse of the order in which they were registered, perform stdio cleanup, and terminate program execution with STATUS. */extern void exit (int __status) __THROW __attribute__ ((__noreturn__)); 在调用exit时，会首先Call all the registered functions, 然后再执行cleanup, terminate program execution with STATUS. 下面我们再看看_exit的定义12/* Terminate program execution with the low-order 8 bits of STATUS. */extern void _exit (int __status) __attribute__ ((__noreturn__)); 直接Terminate program execution. 那么现在问题来了：什么时候调用exit and _exit ?再fork出的child process中需要用_exit, 不能用exit. 因为如果在child process中调用exit, 就会调用atexit中register的functions, 导致parent process的一些tempary file 丢失。 会flush stdio buffer两遍。如上的2可以理解，但是1暂不了解。。。。 12345678910switch (fork()) &#123; case 0: // we're the child execlp("some", "program", NULL); _exit(1); // &lt;-- HERE case -1: // error, no fork done ... default: // we're the parent&#125; 2. atexit 函数老规矩，我们先看在stdlib.h中对atexit的声明12/* Register a function to be called when `exit&apos; is called. */extern int atexit (void (*__func) (void)) __THROW __nonnull ((1)); 注意函数的调用顺序与登记顺序是相反的，其实也就是个 函数栈。 12345678910111213141516171819202122232425#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;static void func1();static void func2();int main(int argc, char** argv)&#123; atexit(func1); atexit(func2); printf("Hello World\n"); exit(0);&#125;void func1()&#123; printf("Call the func1\n");&#125;void func2()&#123; printf("Call the func2\n");&#125; 当进程退出时原文引用APUE的话： |The only way a program can be executed by the kernel is if one of the exec functions iscalled. The only way a process can voluntarily terminate is if _exit or _Exit is called,either explicitly or implicitly (by calling exit). A process can also be involuntarilyterminated by a signal (not shown in Figure 7.2).]]></content>
      <tags>
        <tag>apue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UEAP]]></title>
    <url>%2F2018%2F09%2F18%2FUEAP%2F</url>
    <content type="text"><![CDATA[Chap1 Unix基础知识1.5 输入与输出文件描述符(fd) – 用以标识一个特定的进程正在访问的文件。当内核打开1个现有文件或创建一个新文件，它都返回一个文件描述符。在读写文件时，都可以使用这个fd.每当允许一个新程序，所有的shell都为其打开3个fd: standard input, standard output, standard error.函数open, read, write, lseek, close 提供了不带缓冲的IO. 1234567891011121314151617181920212223#include &quot;apue.h&quot;#include &quot;mysys.h&quot;#define BUFFSIZE 4096int main(void)&#123; int n; char buf[BUFFSIZE]; while((n = read(STDIN_FILENO, buf, BUFFSIZE)) &gt; 0) &#123; if(write(STDOUT_FILENO, buf, n) != n) &#123; err_sys(&quot;Write error&quot;); &#125; &#125; if (n &lt; 0) &#123; err_sys(&quot;read error&quot;); &#125;&#125; 上述code都是定义在&lt;unistd.h&gt;1234567891011121314151617/* Standard file descriptors. */ #define STDIN_FILENO 0 /* Standard input. */ #define STDOUT_FILENO 1 /* Standard output. */ #define STDERR_FILENO 2 /* Standard error output. */ /* Read NBYTES into BUF from FD. Return the number read, -1 for errors or 0 for EOF. This function is a cancellation point and therefore not marked with __THROW. */extern ssize_t read (int __fd, void *__buf, size_t __nbytes) __wur;/* Write N bytes of BUF to FD. Return the number written, or -1. This function is a cancellation point and therefore not marked with __THROW. */extern ssize_t write (int __fd, const void *__buf, size_t __n) __wur; 注意1./a.out &lt; infile &gt; outfile // 会将infile内容复制到outfile 标准I/O – 带缓冲的IO 1.6 程序和进程123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &quot;apue.h&quot;#include &quot;mysys.h&quot;#include &lt;sys/wait.h&gt;int main(void)&#123; char buff[MAXLINE]; pid_t pid; printf(&quot;%% &quot;); // 当按下Ctrl+C, fgets返回NULL, 此时循环终止 // fget的每一行都以\n结尾 while(fgets(buff, MAXLINE, stdin) != NULL) &#123; if(buff[strlen(buff) - 1] == &apos;\n&apos;) &#123; // 因为execlp以NULL终止，所以这里将\n替换为NULL buff[strlen(buff) - 1] = 0; &#125; if((pid = fork()) &lt; 0) &#123; err_sys(&quot;fork failed&quot;); &#125; else if(pid == 0) // child process &#123; execlp(buff, buff, 0); err_ret(&quot;Coundn&apos;t execute: %s&quot;, buff); exit(127); &#125; /* parent */ int status; // wait for a child pid to die if((pid = waitpid(pid,&amp; status, 0)) &lt; 0) &#123; err_sys(&quot;waitpid error&quot;); &#125; printf(&quot;%% &quot;); &#125; exit(0);&#125; 1.7 出错处理errno 用于标识当前系统函数出错的情况. 123/* The error code set by various library functions. */extern int *__errno_location (void) __THROW __attribute_const__;# define errno (*__errno_location ()) 在Linux中将errno按如上定义。在多线程中，每个线程都有自己的errno，从而线程间互不影响。注意errno是全局变量。strerror – 用于打印出errno对应的错误信息perror – 在错误信息的基础上，添加当前errno的对应的出错string. 12345#include &lt;string.h&gt;char* strerror(int errnum);#include &lt;stdio.h&gt;void perror(const char* msg); // 输出为 msg + errno对应的错误string 1234567891011#include &quot;apue.h&quot;#include &lt;errno.h&gt;int main(int argc, char** argv)&#123; fprintf(stderr, &quot;EACCES: %s\n&quot;, strerror(EACCES)); errno = ENOENT; perror(argv[0]); exit(0);&#125; The error numbers are defined in errno-base.h1234567#define EPERM 1 /* Operation not permitted */#define ENOENT 2 /* No such file or directory */#define ESRCH 3 /* No such process */#define EINTR 4 /* Interrupted system call */#define EIO 5 /* I/O error */#define ENXIO 6 /* No such device or address */... Chap3 File I/O3.2 File DescriptorsTo bthe kernel, all open files are referred to by file descriptors.When we create or open a file, the kernel returns a file descriptor to the process which is used to read/write the file1234#include &lt;unistd&gt;#define STDIN_FILENO 0#define STDOUT_FILENO 1#define STDERR_FILENO 2 3.3 open and openat Functions1234#include &lt;fcntl.h&gt;int open(const char* filepath, int a flag, .../* mode_t mode */);int open(int fd, const char* filepath, int a flag, .../* mode_t mode */); The file descriptor returned by open and openat is guaranteed to be the lowest-numbered usunsed descriptor.12345678910111213141516171819202122232425262728293031#include &quot;apue.h&quot;#include &quot;mysys.h&quot;#include &lt;fcntl.h&gt;int main(void)&#123; // create a new file1. int fd = open(&quot;file1&quot;, O_RDONLY | O_WRONLY | O_CREAT | O_TRUNC, FILE_MODE); if(fd == -1) &#123; err_sys(&quot;open failed&quot;); &#125; printf(&quot;fd of file1 is %d&quot;, fd); // Get the fd of dir Debug int dirFd = open(&quot;Debug&quot;, O_DIRECTORY, DIR_MODE); if(dirFd == -1) &#123; err_sys(&quot;open dir failed&quot;); &#125; printf(&quot;dirFD: %d&quot;, dirFd); // create a new file file2 in Debug/ int fd2 = openat(dirFd, &quot;file2&quot;, O_RDONLY | O_WRONLY | O_CREAT | O_TRUNC, FILE_MODE); if(fd2 == -1) &#123; err_sys(&quot;open file2 failed&quot;); &#125; exit(0);&#125; 123#include &lt;fcntl.h&gt;// equivalent to open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);int creat(const char* path, mode_t mode); Note:通过creat创建的file，只能写(O_WRONLY). 如果想实现写的话，需要creat-&gt;close-&gt;open. 或者是1open(path, O_RDONLY | O_WRONLY | O_CREAT | O_TRUNC, mode); 123#include &lt;unistd.h&gt;int close(int fd); Note: All of its open files are closed automatically by the kernel when a process terminates. 3.6 lseek Function每个open的文件都有一个 current file offset , 文件读写都是从这个offset开始的，并且offset会增加the number of bytes read or written.lseek就是来调整这个current file offset的。注意lseek只是调整offset, 不会导致any I/O operation.123#include &lt;unistd.h&gt;off_t lseek(int fd, off_t offset, int whence); // return the new offset if OK, -1 on error 123# define SEEK_SET 0 /* Seek from beginning of file. */# define SEEK_CUR 1 /* Seek from current position. */# define SEEK_END 2 /* Seek from end of file. */ How to get the current offset:12off_t curPos;curPos = lseek(fd, 0, SEEK_CUR); 也可以将offset设置到文件的end后1234567891011121314151617181920212223242526272829303132333435363738394041#include &quot;apue.h&quot;#include &quot;mysys.h&quot;#include &lt;fcntl.h&gt;char buf1[] = &quot;abcdefg&quot;;char buf2[] = &quot;ABCDEFG&quot;;int main(void)&#123; int fd; if((fd = creat(&quot;file.hole&quot;, FILE_MODE)) &lt; 0) &#123; err_sys(&quot;creat error&quot;); &#125; if(write(fd, buf1, 7) != 7) &#123; err_sys(&quot;buf1 write error&quot;); &#125; if(lseek(fd, 16384, SEEK_SET) == -1) &#123; err_sys(&quot;seek error&quot;); &#125; if(write(fd, buf2, 7) != 7) &#123; err_sys(&quot;buf2 write error&quot;); &#125; off_t curPos = lseek(fd, 0, SEEK_CUR); if(curPos == -1) &#123; err_sys(&quot;seek cur pos error&quot;); &#125; printf(&quot;%d\n&quot;, curPos); exit(0);&#125; file.hole的内容是123456dylanz@vbox:~/study/ueap$ od -c file.hole 0000000 a b c d e f g \0 \0 \0 \0 \0 \0 \0 \0 \00000020 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0*0040000 A B C D E F G0040007 read/write Function1234#include &lt;unistd.h&gt;// return number of bytes read; 0 if end of file; -1 on errorssize_t read(int fd, void *buf, size_t nbytes); 3.10 File Sharing 如上图，包含3个部分： process table entry这个是per process的，其中包括了在这个process上打开文件的fd. Associated with each fd are: The file descriptor flags. a pointer to a file table entry. file table entry这个不是per process的。对于被不同process打开的同一文件，会有多个file table entry.其中包含了file status flag and current file offset，都是用于操作文件的。 Vnode table entry这个是真正的per file的，包含the type of the file and pointers to the functions that operate on the file. 此外，大多数files还包括inode info. 下面是2个processes打开同一文件的示意图: 注意每个process都有自己的file table entry，其实这也是可以理解的，因为file table entry中包括的是flags and offset 对与每个process很可能是不同的。当进行如下操作时： write current file offset in file table entry会增加the number of written bytes. 如果current file offset &gt; current file size in i-node, current file size也会更新为current file offset. write with O_APPEND.在每次写之前，都会将current file offset in file table entry 设置为current file size in i_node. 这样就会force every write to be appended to the current end of file. lseeklseek 只会修改current file offset in file table entry , 不会改v-node中的内容。 请注意下面的描述，不是很明白1234It is possible for more than one ﬁle descriptor entry to point to the same ﬁle tableentry, as we’ll see when we discuss the dup function in Section 3.12. This also happensafter a fork when the parent and the child share the same ﬁle table entry for each opendescriptor (Section 8.3). Note: The difference between the file descriptor flags and file status flag File descriptor flags(in file descriptor entry): Apply to a single descriptor in a single process. file status flag(in file table entry): Apply to all descriptors in any process that point to the given file table entry. 3.11 Atomic Operations Appending to a File 123456789if(lseek(fd, 0L, 2) &lt; 0)&#123; err_sys(&quot;lseek error&quot;);&#125;if(write(fd, buf. 100) != 100)&#123; err_sys(&quot;write error&quot;);&#125; 如上code， 如果有2个process同时Appending to a file, 就会发生冲突.1) process A, B 同时对file通过如上code进行append操作。此时会产生2个file table entry.2) In process A, lseek 将current file offset设置到file end. 例如到15003) In process B, lseek 将current file offset设置到file end, 为15004）In process B, write 100个byte，此时current file offset and current file size 均为1600.5）In process A, 开始write，但是此时current file offset为1500, overwrite 了B写的内容。 此外，UNIX system provides an atomic way to do this operation if we set the O_APPEND flag when a file is opened. pread and pwrite Functionspread = lseek + readpwrite = lseek + write 12345678910111213141516/* Read NBYTES into BUF from FD at the given position OFFSET without changing the file pointer. Return the number read, -1 for errors or 0 for EOF. This function is a cancellation point and therefore not marked with __THROW. */extern ssize_t pread (int __fd, void *__buf, size_t __nbytes, __off_t __offset) __wur;/* Write N bytes of BUF to FD at the given position OFFSET without changing the file pointer. Return the number written, or -1. This function is a cancellation point and therefore not marked with __THROW. */extern ssize_t pwrite (int __fd, const void *__buf, size_t __n, __off_t __offset) __wur; Creating a File]]></content>
      <tags>
        <tag>Linux UEAP</tag>
      </tags>
  </entry>
</search>
