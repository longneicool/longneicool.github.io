<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[线程]]></title>
    <url>%2F2018%2F11%2F06%2F%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[线程的标识也就是线程id,即pthread_t.1234567#include &lt;pthread.h&gt;/* Obtain the identifier of the current thread. */extern pthread_t pthread_self (void) __THROW __attribute__ ((__const__));/* Compare two thread identifiers. */extern int pthread_equal (pthread_t __thread1, pthread_t __thread2) __THROW __attribute__ ((__const__)); pthread_create线程的创建是通过pthread_create来完成 1234567/* Create a new thread, starting with execution of START-ROUTINE getting passed ARG. Creation attributed come from ATTR. The new handle is stored in *NEWTHREAD. 0 - success， 否则返回error code*/extern int pthread_create (pthread_t *__restrict __newthread, const pthread_attr_t *__restrict __attr, void *(*__start_routine) (void *), void *__restrict __arg) __THROWNL __nonnull ((1, 3)); 新创建的线程是从start_routine开始run的，arg是该函数的参数. pthread_create的用法比较简单，但是需要注意： 线程创建时 新线程与调用线程的运行顺序不确定 pthread_create函数在调用失败时会返回错误码，但不会像其他PISIX函数设置errno，每个线程都有errno副本。 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include "apue.h"#include &lt;pthread.h&gt;#include "mysys.h"#include &lt;unistd.h&gt;void print_ids()&#123; pid_t pid = getpid(); pthread_t tid = pthread_self(); printf("pid %lu tid 0x%lx\n", pid, tid);&#125;void* start_run(void* param)&#123; print_ids(); return (void*)0;&#125;int main(int argc, char** argv)&#123; pthread_t tid = 0; int res = pthread_create(&amp;tid, nullptr, start_run, nullptr); if(res &lt; 0) &#123; err_sys("failed to create pthread"); &#125; sleep(1); print_ids(); exit(0);&#125; 如果把上述的code改为 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include "apue.h"#include &lt;pthread.h&gt;#include "mysys.h"#include &lt;unistd.h&gt;void print_ids()&#123; pid_t pid = getpid(); pthread_t tid = pthread_self(); printf("pid %lu tid 0x%lx\n", pid, tid);&#125;void* start_run(void* param)&#123; // 这里的tid不一定为新线程的id，因为新线程与调用线程的运行顺序不一致。 // 如果新线程先运行，调用线程后给tid赋值，则此处的tid为0. // 也就是多线程要考虑race condition pthread_t tid = *((pthread_t*)param); printf("tid is %ld\n", tid); return (void*)0;&#125;int main(int argc, char** argv)&#123; pthread_t tid = 0; int res = pthread_create(&amp;tid, nullptr, start_run, (void*)&amp;tid); if(res &lt; 0) &#123; err_sys("failed to create pthread"); &#125; exit(0);&#125; Thread Terminationthread退出有3种方式： return from start routine pthread_exit() pthread_cancel by other threads. 12345678910#include &lt;pthread.h&gt;/* Terminate calling thread.*/extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));/* Make calling thread wait for termination of the thread TH. The exit status of the thread is stored in *THREAD_RETURN, if THREAD_RETURN is not NULL.*/extern int pthread_join (pthread_t __th, void **__thread_return); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include "apue.h"#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include "mysys.h"// 通过推出start routine退出thread，return code 即是thread exit codevoid * print_thread1(void *arg)&#123; printf("run in thread1\n"); return ((void*)1);&#125;// 通过pthread_exit()退出void * print_thread2(void *arg)&#123; printf("run in thread2\n"); pthread_exit((void*)2);&#125;void *print_thread3(void *arg)&#123; printf("run in thread3"); //在thread中调用exit _exit _Exit，会退出entire process exit(3);&#125;void check_err(int err)&#123; if(err != 0) &#123; err_sys("Failed to create thread\n"); &#125;&#125;void join(const pthread_t&amp; tid)&#123; void *tret; int err = pthread_join(tid, &amp;tret); check_err(err); printf("retval of tid 0x%lx is %ld\n", tid, (long)tret);&#125;int main(int argc, char** argv)&#123; pthread_t tid1; int res = pthread_create(&amp;tid1, nullptr, print_thread1, nullptr); check_err(res); join(tid1); pthread_t tid2; int res2 = pthread_create(&amp;tid2, nullptr, print_thread2, nullptr); check_err(res2); join(tid2); pthread_t tid3; int res3 = pthread_create(&amp;tid3, nullptr, print_thread3, nullptr); check_err(res3); join(tid3); exit(0);&#125; Note: pthread_create and pthread_exit的void*可以传递更复杂的内容。但是需要注意，如果你传递指针的话，就会存在线程间的race condition，即这个指针指向的对象在1个thread发生变化，在另外1个thread也会做对应的改变。 12345678910111213141516171819202122232425262728293031323334#include "apue.h"#include "mysys.h"#include &lt;pthread.h&gt;void* thread_run(void* arg)&#123; while(true) &#123; printf("The arg in new thread is 0x%lx\n", arg); printf("arg:%ld\n", *((int*)arg)); sleep(1); &#125;&#125;int main(int argc, char** argv)&#123; pthread_t tid; int val = 1; int res = pthread_create(&amp;tid, nullptr, thread_run, (void*)&amp;val); if(res != 0) &#123; err_sys("Failed to create thread"); &#125; while(true) &#123; val++; printf("The arg in main thread is 0x%lx\n", &amp;val); printf("arg:%ld\n", val); sleep(1); &#125; exit(0);&#125; The output is123456789101112131415161718192021222324The arg in main thread is 0x7ffe5ebaf6a8arg:2The arg in new thread is 0x7ffe5ebaf6a8arg:2The arg in main thread is 0x7ffe5ebaf6a8arg:3The arg in new thread is 0x7ffe5ebaf6a8arg:3The arg in main thread is 0x7ffe5ebaf6a8arg:4The arg in new thread is 0x7ffe5ebaf6a8arg:4The arg in main thread is 0x7ffe5ebaf6a8arg:5The arg in new thread is 0x7ffe5ebaf6a8arg:5The arg in main thread is 0x7ffe5ebaf6a8arg:6The arg in new thread is 0x7ffe5ebaf6a8arg:6The arg in main thread is 0x7ffe5ebaf6a8arg:7The arg in new thread is 0x7ffe5ebaf6a8arg:7 11.6 线程同步11.6.1 互斥量互斥量用pthread_mutex_t表示，使用顺序是：初始化 -&gt; block -&gt; unblock -&gt; destroy(动态分配)12345678910// 初始化#include &lt;pthread.h&gt;/* Initialize a mutex. */extern int pthread_mutex_init (pthread_mutex_t *__mutex, const pthread_mutexattr_t *__mutexattr) __THROW __nonnull ((1));// 只适用于静态分配的变量# define PTHREAD_MUTEX_INITIALIZER \ &#123; &#123; 0, 0, 0, 0, 0, __PTHREAD_SPINS, &#123; 0, 0 &#125; &#125; &#125; 12345678910/* Try locking a mutex. */// 只是尝试lock，不会阻塞线程, 如果已经lock了，则会失败，返回EBUSY // 如果未lock，则会lock住extern int pthread_mutex_trylock (pthread_mutex_t *__mutex) __THROWNL __nonnull ((1));/* Lock a mutex. */// 如果mutex被lock，则调用线程将被阻塞直到互斥变量被解锁。extern int pthread_mutex_lock (pthread_mutex_t *__mutex) __THROWNL __nonnull ((1)); 123/* Unlock a mutex. */extern int pthread_mutex_unlock (pthread_mutex_t *__mutex) __THROWNL __nonnull ((1)); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;struct foo &#123; pthread_mutex_t _mutex; int _count; int _id;&#125;;struct foo* foo_alloc(int id)&#123; struct foo* p_foo = malloc(sizeof(struct foo)); if(p_foo == nullptr) &#123; printf(&quot;Failed to malloc\n&quot;); return nullptr; &#125; p_foo-&gt;_count = 1; p_foo-&gt;_id = id; if(0 != pthread_mutex_init(&amp;(p_foo-&gt;_mutex), nullptr)) &#123; printf(&quot;Failed to init mutex\n&quot;); free(p_foo); return nullptr; &#125; return p_foo;&#125;void foo_hold(struct foo* f)&#123; pthread_mutex_lock(&amp;(f-&gt;_mutex)); f-&gt;_count++; pthread_mutex_unlock(&amp;(f-&gt;_mutex));&#125;void foo_rel(struct foo *f)&#123; pthread_mutex_lock(&amp;(f-&gt;_mutex)); f-&gt;_count--; if(f-&gt;_count == 0) &#123; pthread_mutex_unlock(&amp;(f-&gt;_mutex)); pthread_mutex_destroy(&amp;(f-&gt;_mutex)); free(f); &#125; else &#123; pthread_mutex_unlock(&amp;(f-&gt;_mutex)); &#125;&#125; 上述code有个问题，假如有其他线程在调用foo_hold，那么当foo_rel在调用时，即使此时_count为0时，此时destroy也是不合适的。 11.6.4 读写锁读写锁很好理解，就是有3种模式：读模式，写模式，无锁模式只有在写模式下，当以写模式被锁住时，其他的线程当调用此锁时会被阻塞住。 12345678910111213/* Initialize read-write lock RWLOCK using attributes ATTR, or use the default values if later is NULL. */extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock, const pthread_rwlockattr_t *__restrict __attr) __THROW __nonnull ((1));/* Read-write lock initializers. */// 还是用于初始化静态分配的ｌｏｃｋ# define PTHREAD_RWLOCK_INITIALIZER \/* Destroy read-write lock RWLOCK. */extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock) __THROW __nonnull ((1)); 在释放读写锁内存之前，需要调用pthread_rwlock_destroy做清理工作 1234567891011/* Acquire read lock for RWLOCK. */extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock) __THROWNL __nonnull ((1));/* Acquire write lock for RWLOCK. */extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock) __THROWNL __nonnull ((1)); /* Unlock RWLOCK. */extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock) __THROWNL __nonnull ((1)); 如下的ｃｏｄｅ实现了１个ｑｕｅｕｅ，通过主线程向ｑｕｅｕｅ中写入ｊｏｂ，并且分配好ｊｏｂ由那个thread来完成。而各个ｗｏｒｋｅｒ ｔｈｒｅａｄ从ｑｕｅｕｅ中来取ｊｏｂ干活。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132/* * rw_mutex.cpp * * Created on: Dec 2, 2018 * Author: dylanz */#include "apue.h"#include "mysys.h"#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;struct job &#123; struct job* j_next; struct job* j_prv; pthread_t j_id;&#125;;struct queue &#123; struct job *q_head; struct job *q_tail; pthread_rwlock_t q_rwlock;&#125;;int queue_int(struct queue *qp) &#123; int err; qp-&gt;q_head = nullptr; qp-&gt;q_tail = nullptr; err = pthread_rwlock_init(&amp;qp-&gt;q_rwlock, nullptr); if( err != 0) &#123; return err; &#125; return 0;&#125;void job_insert(struct queue *qp, struct job *jp)&#123; int ret = pthread_rwlock_wrlock(&amp;qp-&gt;q_rwlock); if(ret != 0) &#123; printf("Failed to get the rwlock from the queue"); return; &#125; jp-&gt;j_prv = nullptr; jp-&gt;j_next = qp-&gt;q_head; if(qp-&gt;q_head != nullptr) &#123; qp-&gt;q_head-&gt;j_prv = jp; &#125; else &#123; qp-&gt;q_tail = jp; &#125; qp-&gt;q_head = jp; pthread_rwlock_unlock(&amp;qp-&gt;q_rwlock);&#125;void job_append(struct queue *qp, struct job* jb)&#123; pthread_rwlock_wrlock(&amp;qp-&gt;q_rwlock); jb-&gt;j_next = nullptr; jb-&gt;j_prv = qp-&gt;q_tail; if(qp-&gt;q_tail == nullptr) &#123; qp-&gt;q_head = jb; &#125; else &#123; qp-&gt;q_tail-&gt;j_next = jb; &#125; qp-&gt;q_tail = jb; pthread_rwlock_unlock(&amp;qp-&gt;q_rwlock);&#125;void job_remove(struct queue *qp, struct job *jb)&#123; pthread_rwlock_wrlock(&amp;qp-&gt;q_rwlock); if(qp-&gt;q_head == jb &amp;&amp; qp-&gt;q_tail == jb) &#123; qp-&gt;q_head = nullptr; qp-&gt;q_tail = nullptr; pthread_rwlock_wrlock(&amp;qp-&gt;q_rwlock); return; &#125; if(qp-&gt;q_head == jb) &#123; qp-&gt;q_head = qp-&gt;q_head-&gt;j_next; qp-&gt;q_head-&gt;j_prv = nullptr; pthread_rwlock_wrlock(&amp;qp-&gt;q_rwlock); return; &#125; if(qp-&gt;q_tail == jb) &#123; qp-&gt;q_tail = qp-&gt;q_tail-&gt;j_prv; qp-&gt;q_tail-&gt;j_next = nullptr; pthread_rwlock_wrlock(&amp;qp-&gt;q_rwlock); return; &#125; jb-&gt;j_prv-&gt;j_next = jb-&gt;j_next; jb-&gt;j_next-&gt;j_prv = jb-&gt;j_prv; pthread_rwlock_wrlock(&amp;qp-&gt;q_rwlock);&#125;struct job* job_find(struct queue *qp, pthread_t tid)&#123; pthread_rwlock_rdlock(&amp;qp-&gt;q_rwlock); struct job* jp= qp-&gt;q_head; for(; jp!= nullptr; jp = jp-&gt;j_next) &#123; if(pthread_equal(jp-&gt;j_id, tid)) &#123; break; &#125; &#125; pthread_rwlock_unlock(&amp;qp-&gt;q_rwlock); return jp;&#125; 11.6.6 条件变量条件变量是线程可用的另一种同步机制。其实就是１个线程等待某种条件，其他线程可以做自己的事情。当在线程２满足线程１的条件时，就发出１个ｓｉｇｎａｌ，这是在等待的线程１会就会结束等待，进行下一步。条件变量使用可以分为以下几步： Init Condition在使用之前必须对条件变量进行初始化。 1234567#include &lt;pthread.h&gt;/* Initialize condition variable COND using attributes ATTR, or use the default values if later is NULL. */extern int pthread_cond_init (pthread_cond_t *__restrict __cond, const pthread_condattr_t *__restrict __cond_attr) __THROW __nonnull ((1));pthread_cond_t cond = PTHREAD_COND_INITIALIZER; 在结束时需要用ｄｅｓｔｒｏｙ释放ｃｏｎｄｉｔｉｏｎ123/* Destroy condition variable COND. */extern int pthread_cond_destroy (pthread_cond_t *__cond) __THROW __nonnull ((1)); wait condition如下，把mutex传递给ｗａｉｔ函数，注意传递的ｍｕｔｅｘ必须是ｌｏｃｋ的。ｗａｉｔ函数收到ｌｏｃｋ的ｍｕｔｅｘ之后，自动把调用线程放到等待条件的线程列表上，然后会对ｍｕｔｅｘ进行解锁，这样其他线程就可以使用该ｍｕｔｅｘ保护的内容了。 当ｗａｉｔ函数收到ｓｉｇｎａｌ之后，ｗａｉｔ函数返回，并且将ｍｕｔｅｘ进行ｌｏｃｋ。这样就相当于将ｍｕｔｅｘ保护变量的使用权又交回到ｗａｉｔ的线程。 注意调用完ｗａｉｔ函数，会将该线程ｂｌｏｃｋ住。 12345678/* Wait for condition variable COND to be signaled or broadcast. MUTEX is assumed to be locked before. This function is a cancellation point and therefore not marked with __THROW. */extern int pthread_cond_wait (pthread_cond_t *__restrict __cond, pthread_mutex_t *__restrict __mutex) __nonnull ((1, 2)); send signal 1234567/* Wake up one thread waiting for condition variable COND. */extern int pthread_cond_signal (pthread_cond_t *__cond) __THROWNL __nonnull ((1));/* Wake up all threads waiting for condition variables COND. */extern int pthread_cond_broadcast (pthread_cond_t *__cond) __THROWNL __nonnull ((1)); ｗａｉｔ线程收到ｓｉｇｎａｌ,继续处理注意处理完之后，需要调用pthread_mutex_unlock(&amp;_mutex) 进行unlock. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;pthread.h&gt;#include "apue.h"#include "mysys.h"struct Condition&#123; Condition() &#123; //1. 在使用之前必须对ｃｏｎｄｉｔｉｏｎ进行ｉｎｉｔ _initializer = pthread_cond_init(&amp;_condition, nullptr); &#125; ~Condition() &#123; if(_initializer) &#123; // ２. 在结束时，需要将condition进行ｄｅｓｔｒｏｙ pthread_cond_destroy(&amp;_condition); &#125; &#125; void wait(pthread_mutex_t &amp;mutex) &#123; pthread_cond_wait(&amp;_condition, &amp;mutex); &#125; void signal(pthread_mutex_t &amp;mutex) &#123; pthread_cond_signal(&amp;_condition); &#125; void broadcast(pthread_mutex_t &amp;mutex) &#123; pthread_cond_broadcast(&amp;_condition); &#125;private: pthread_cond_t _condition; bool _initializer;&#125;;struct Queue&#123; static Queue&amp; get_instance() &#123; static Queue queue; return queue; &#125; void enqueue(int i) &#123; pthread_mutex_lock(&amp;_mutex); _queue.push(i); //7. 注意下面的顺序，先unlock, 在send signal // 否则ｓｉｇｎａｌ发出去也不起作用，因为mutex还被ｌｏｃｋ住，ｗａｉｔ线程仍然会阻塞住，直到 // mutex被unlock. pthread_mutex_unlock(&amp;_mutex); _cond.signal(_mutex); &#125; int pop() &#123; //3. 在ｗａｉｔ之前必须将mutex进行lock. pthread_mutex_lock(&amp;_mutex); //4. 持续等待ｃｏｎｄｉｔｉｏｎ while(empty()) &#123; std::cout &lt;&lt; "empty: " &lt;&lt; empty() &lt;&lt; std::endl; //5. 等待线程ｗａｉｔ ｃｏｎｄｉｔｉｏｎ _cond.wait(_mutex); &#125; int v = _queue.front(); _queue.pop(); // 6. 在处理完之后必须将ｍｕｔｅｘ ｕｎｌｏｃｋ pthread_mutex_unlock(&amp;_mutex); return v; &#125; bool empty() &#123; return _queue.empty(); &#125; void clear() &#123; std::queue&lt;int&gt; empty; //7. queue没有ｃｌｅａｒ函数，一般通过swap empty queue ｃｌｅａｒ swap(_queue, empty); &#125;private: Queue() = default; std::queue&lt;int&gt; _queue; Condition _cond; pthread_mutex_t _mutex = PTHREAD_MUTEX_INITIALIZER;&#125;;void* managerFunc(void* arg)&#123; for(int i = 0; i &lt; 10; i++) &#123; Queue::get_instance().enqueue(i); std::cout &lt;&lt; "Enqueue done! " &lt;&lt; i &lt;&lt; std::endl; sleep(1); &#125; return (void*) 0;&#125;void* workFunc(void* arg)&#123; while(1) &#123; int i = Queue::get_instance().pop(); std::cout &lt;&lt; "the received i is " &lt;&lt; i &lt;&lt; std::endl; &#125; return (void*) 0;&#125;int main(int argc, char** argv)&#123; pthread_t managerTid; int ret = pthread_create(&amp;managerTid, nullptr, managerFunc, nullptr); if( ret != 0 ) &#123; err_sys("Failed to create thread"); &#125; pthread_t workTid; ret = pthread_create(&amp;workTid, nullptr, workFunc, nullptr); if( ret != 0) &#123; err_sys("Failed to create worker thread"); &#125; sleep(100);&#125;]]></content>
      <tags>
        <tag>apue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ShareMemory]]></title>
    <url>%2F2018%2F10%2F30%2FShareMemory%2F</url>
    <content type="text"><![CDATA[Identifiers and KeysIdentifiers: Each IPC structure(message queue, semaphore, or share memory segment) is referred to by a non-negative integer identifier. 主要用于send/fetch the content from the IPC structure.需要注意The identifier is an internal name for an IPC object. 在Cooperating processes之间，就需要an external namin scheme, 也就是key。 在创建IPC structure时，需要指定key，比如1extern int shmget (key_t __key, size_t __size, int __shmflg) __THROW; 那么怎么来获取key呢？ The server can create a new IPC structure by specifying a key of IPC_PRIVATE and store the returned identifier somewhere(such as a file ) for the client to obtain.注意通过key IPC_PRIVATE 只能用于create a new IPC structure, 后续无法通过这个key来access IPC structure.IPC_PRIVATE key 也用在parent-child relationship. 在parent中create IPC structure, 这个Identifier is available in child process after fork(). 在child process会获取parent data的副本 1234567891011121314151617181920#include &lt;sys/shm.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;int main(int argc, char ** argv)&#123; int id = shmget(IPC_PRIVATE, 1024, IPC_CREAT | IPC_EXCL | 0666); pid_t child = fork(); if(child == 0) &#123; std::cout &lt;&lt; "id in child is " &lt;&lt; id &lt;&lt; std::endl; exit(0); &#125; std::cout &lt;&lt; "id in parent is " &lt;&lt; id &lt;&lt; std::endl; exit(0);&#125; The client and the server can agree on a key by defining the key in a common header ftok12#include &lt;sys/ipc.h&gt; key_t ftok(const char *path, int id);]]></content>
      <tags>
        <tag>apue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell]]></title>
    <url>%2F2018%2F10%2F15%2FShell%2F</url>
    <content type="text"><![CDATA[1 小试牛刀打印 printf 123456printf "%-5s %-10s %-4s\n" No Name Markprintf "%-5s %-10s %-4s\n" 1 Andy 19printf "%-5s %-10s %-4s\n" 2 Bob 20printf "%-5s %-10s %-4s\n" 3 Cal 39printf "%-5s %-10s %-4s\n" 4 Deny 50printf "%-5s %-10s %-4s\n" 5 Edle 60 打印颜色echo -e &quot;\e[1;32m This is red text \e[0m&quot;\e[1;32m将颜色设置为红色。\e[0m将颜色恢复经常使用的颜色有： 重置=0, 黑色=40, 红色=41, 绿色=42, 黄色=43, 蓝色=44, 洋红=45, 青色=46, 白色=47 重定向ls + . &gt; output 2&gt;&amp;1如上是从右往左运算的，先将2与1绑定起来，然后将输出重定向到output文件 如果想将输出既输出到stdin，也存1份到output文件，应该用tee123tee - read from standard input and write to standard output and files$ll | tee output | cat -n // 将ll的输出保存到output，最后cat -n是从stdin读取，然后加上行号 注意tee只能从stdin读取如果想stderr也输出，就需要重定向绑定ls + . 2&gt;&amp;1 | tee output 还可以通过cmd &lt; file 来读取文件内容1234!/bin/bashfor v in $(&lt;$1); do echo $vdone 数组12345#!/bin/bash# 普通数组str_arr=(&quot;test1&quot; &quot;test2&quot; &quot;test3&quot;)echo $&#123;str_arr[*]&#125; # print all array contentsecho $&#123;#str_arr[*]&#125; # print array len 12345# 关联数组declare -A ass_arrayass_array=([&quot;apple&quot;]=&quot;100$&quot; [&quot;orange&quot;]=120$)echo &quot;Apple price is $&#123;ass_array[&quot;apple&quot;]&#125;&quot;echo $&#123;!ass_array[*]&#125; date123456#!/bin/bash# caulate the command used timestart_date=`date +%s`sleep 10echo &quot;Total used $(expr `date +%s` - $start_date) s&quot; 命令之乐cat123cat file1 file2 file3 # 拼接多个文件cat -s file1 # 删除相邻的空行cat -T file1 # 显示制表符 1echo &apos;Text through stdin&apos; | cat - file.txt # 将stdin 与 file拼接起来，- 表示stdin文件 Usefull ScriptMulti operation in other lab12345678910111213141516171819202122#!/bin/sh# multissh.shtmpdir=$&#123;TMPDIR:-/tmp&#125;/pssh.$$mkdir -p $tmpdircount=0while IFS= read -r userhost; do ssh -n -o BatchMode=yes $2@$&#123;userhost&#125; $3 &gt; $&#123;tmpdir&#125;/$&#123;userhost&#125; 2&gt;&amp;1 &amp; #expect "assword:" #send "yt_xk39b\r" count=`expr $count + 1`done &lt; $1.lstwhile [ $count -gt 0 ]; do wait $pids count=`expr $count - 1`doneecho "Output for hosts are in $tmpdir"while IFS= read -r userhost; docat $&#123;tmpdir&#125;/$&#123;userhost&#125;done &lt; $1.lst 1234# multiscp.shfor dest in $(&lt;$1.lst); do scp $2 $&#123;dest&#125;:/home/rtp99done 123456789101112# usage./multiscp.sh hss DIA/libDiaAvpValidators.so./multiscp.sh hss DIA/libDiameterBase.so./multissh.sh hss root &quot;cd /home/rtp99; sh patch_unpatch.sh unpatch&quot;./multissh.sh hss root &quot;cd /home/rtp99; rm libDiameterBase.so&quot;./multissh.sh hss root &quot;cd /home/rtp99; sh patch_unpatch.sh patch&quot;./multissh.sh hss rtp99 &quot;/opt/SMAW/bin/execRTPenv /opt/SMAW/INTP/bin/IcmAdminTool.pl ProcessesStop IMS_P_UMS&quot;./multissh.sh hss rtp99 &quot;/opt/SMAW/bin/execRTPenv /opt/SMAW/INTP/bin/IcmAdminTool.pl ProcessesStart IMS_P_UMS&quot;./multissh.sh hss root &quot;cd /home/rtp99; chmod 777 libDiameterBase.so&quot;./multissh.sh hss root &quot;cd /home/rtp99; chmod 777 libDiaAvpValidators.so&quot;./multissh.sh all rtp99 &quot;sed -i &apos;s/IcmReceiverCount.IMS_DIAMETER=10/IcmReceiverCount.IMS_DIAMETER=4/g&apos; /opt/SMAW/INTP/config/icm.cfg&quot;./multissh.sh all rtp99 &quot;sed -i &apos;\$aIcmComReceiverThreadCount=4&apos; /opt/SMAW/INTP/config/icm.cfg&quot;]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chap8 进程控制]]></title>
    <url>%2F2018%2F10%2F09%2F%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[8.4 fork12345#include &lt;unistd.h&gt;/* Clone the calling process, creating an exact copy. Return -1 for errors, 0 to thef new process, and the process ID of the new process to the old process. */int fork(); fork是基于当前的process new1个新的process。fork分别再child process and parent process被调用1次。在child process中，fork返回0。在parent process中，fork返回child process的pid。child process 和 parent process继续执行fork之后的code，child process会获得parent process的数据空间，堆，栈的副本。 堆，栈，数据空间的副本 12345678910111213141516171819202122232425262728293031323334353637383940#include "apue.h"#include "mysys.h"#include &lt;unistd.h&gt;int globvar = 6;char buf[] = "a write to stdcout\n";int main(int argc, char** argv)&#123; int var = 80; if(write(STDOUT_FILENO, buf, sizeof(buf) - 1) != sizeof(buf) - 1) &#123; err_sys("write error"); &#125; printf("before fork\n"); pid_t pid; pid = fork(); if(pid &lt; 0) &#123; err_sys("fork failed"); &#125; else if(pid == 0) &#123; std::cout &lt;&lt; "In Child process" &lt;&lt; std::endl; globvar++; var = 1; &#125; else &#123; std::cout &lt;&lt; "In Parent process" &lt;&lt; std::endl; sleep(2); &#125; printf("pid=%d, glob=%d, var=%d\n", (long)getpid(), globvar, var); exit(0);&#125; 如果执行 ./a.out, 输出为 123456a write to stdcoutbefore forkIn Parent processIn Child processpid=3075, glob=7, var=1pid=3074, glob=6, var=80 其中3075是child process, 3074为parent process，从上可以看出这两个process的glob 和 var不同，glob是在data段，var在栈中。再次验证了child process 和parent process拥有不同的堆栈数据空间等等 缓冲区的副本对以上的程序，如果执行./a.out &gt; temp, 则输出为123456789dylanz@vbox:~/study/ueap$ ./a.out &gt; temp.out dylanz@vbox:~/study/ueap$ cat temp.out a write to stdcoutbefore forkIn Parent processbefore forkIn Child processpid=3095, glob=7, var=1pid=3094, glob=6, var=80 before fork被打印了两次，why？因为输出到文件中时，执行的是全缓冲。当执行到printf \n时，并不会flush 缓冲区，而是继续将数据保存再缓冲区中。当fork时，child process也会得到缓冲区的副本，从而会打印两次。而再命令行操作时，执行的时行缓冲，数据再printf \n时，缓冲区就已经被flush了。 | 全缓冲 指系统再填满标准IO缓冲区之后才进行实际的IO操作。对于驻留再磁盘上的文件来说通常是由标准IO实现的全缓冲 行缓冲 标准IO再输入和输出中遇到换行符时执行I/O操作。当流涉及到终端时，通常使用的是行缓冲 无缓冲 标准出错流stderr通常时无缓冲的 文件共享看如下的code，会输出啥？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;unistd.h&gt;#include "apue.h"#include "mysys.h"#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;void write_str(bool is_child, int fd)&#123; const char child_buf[] = "I am in child process"; const char parent_buf[] = "I am in parent process"; const char* buf = is_child ? child_buf : parent_buf; int len = write(fd, buf, strlen(buf) - 1); if(len != strlen(buf) - 1) &#123; err_sys("Failed to write data in child process"); &#125; int cur_pos = lseek(fd, 0, SEEK_CUR); printf("Current pos is %d\n", cur_pos);&#125;int main(int argc, char** argv)&#123; int fd = creat("fork.txt", FILE_MODE); if(fd &lt; 0) &#123; err_sys("Failed to creat the file fork.txt"); &#125; pid_t child_pid = fork(); if(child_pid &lt; 0) &#123; err_sys("failed to fork"); &#125; else if(child_pid == 0) // in child process &#123; write_str(true, fd); &#125; else &#123; sleep(2); write_str(false, fd); &#125;&#125; 再fork.txt中的内容为：I am in child procesI am in parent proces可以看到其中的string没有重叠部分，parent process的写入内容在child process之后。这说明了啥？以上说明了parent process与child process共享同一文件偏移量。实际上，fork的一个特性就是parent process的所有打开的file descriptor都会被复制到child process中，等价与执行了dup 函数。 总结fork有以下两种用法： 1个parent process希望复制自己，使parent process and child process同时执行不同的代码段。这在网络服务中非常常见，—parent process等待客户端的服务请求，当这种请求到达时，parent process调用fork，使得child process处理此请求。parent process则继续等待下一个服务请求 一个进程要执行一个不同的程序，在这种情况下，child process从fork返回后，立即调用exec… 8.5 函数exit本节主要介绍再进程退出时父进程与子进程的关系。进程有5种正常和3种异常终止方式，5种正常终止方式有： 在main中return 2. 调用exit 3. 调用_exit 4. 进程的最后1个线程再其启动例程中执行return语句。但是该线程的返回值不作为进程的返回值。此时进程的终止状态为0 5. 进程的最后1个线程调用pthread_exit，但是进程的终止状态依然为0. 异常终止状态有：1) 调用abort 2) 进程收到某些信息 3) 最后一个线程对cancellation请求作出响应。 无论对于那一种退出方式，我们都希望终止进程能够通知其父进程它是如何终止的对于正常终止来说，终止进程将其exit status作为参数传到exit或_exit函数中，然后再转换为termination status对于异常终止来说，内核会产生一个指示其异常终止原因的termination status。无论以上那种情况，该终止进程的父进程都能用wait或waitpid函数取得其终止状态。123456/* Wait for a child to die. When one does, put its status in *STAT_LOC and return its process ID. For errors, return (pid_t) -1. This function is a cancellation point and therefore not marked with __THROW. */extern __pid_t wait (int *__stat_loc); 1234567891011121314151617181920212223242526272829303132333435#include "apue.h"#include "mysys.h"#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdlib.h&gt;void pr_exit(int status)&#123; if(WIFEXITED(status)) printf("normal termination, exit status = %d\n", WEXITSTATUS(status)); else if(WIFSIGNALED(status)) printf("abnormal termination, signal number = %d%s\n", WTERMSIG(status),#ifdef WCOREDUMP WCOREDUMP(status) ? "(core file generated)" : "");#endif else if(WIFSTOPPED(status)) printf("child stopped, signal number = %d\n", WSTOPSIG(status));&#125;int main(int argc, char** argv)&#123; pid_t child = fork(); if(child &lt; 0) &#123; err_sys("fork failed"); &#125; else if(child == 0) &#123; int a = 1 / 0; &#125; int status; pid_t p = wait(&amp;status); pr_exit(status);&#125; 输出为： abnormal termination, signal number = 8(core file generated) 下面我们就讨论子进程与父进程的终止关系 子进程在父进程之前终止 1) 如果是正常终止，则将其exit status作为参数传递给exit函数 2) 如果是异常终止，内核会为每个终止的紫禁城保存一定量的信息，父进程可以同感wait函数调用 父进程再子进程之前终止对于父进程已经终止的所有进程，他们的父进程都改变为init进程，即这些进程被init进程收养。其大概操作步骤是：当一个进程终止时，内核会检查其是否还有子进程，如果有，则将这些子进程的父进程全部改为init进程，从而保证每个进程有1个父进程。 12345678910111213141516171819202122232425262728#include "apue.h"#include "mysys.h"#include &lt;unistd.h&gt;int main(int argc, char** argv)&#123; pid_t child = fork(); if(child &lt; 0) &#123; err_sys("Failed to fork"); &#125; else if(child == 0) &#123; int n = 0; while(n &lt; 100) &#123; sleep(1); printf("ppid:%d\n", getppid()); n++; &#125; &#125; else &#123; sleep(2); &#125; return 0;&#125; 以上程序的输出是ppid:2688ppid:1ppid:1ppid:1ppid:1ppid:1ppid:1ppid:1ppid:1ppid:1 如上可见，在2s后，父进程退出后，child进程的父进程会改为init进程(pid为1).zombie进程 – 对于一个已经终止，但是其父进程尚未对其进行善后处理（获取终止子进程的有关信息，释放它仍占用的资源）的进程成为zombie进程。 由init进程收养的进程终止时，会不会变成zombie 进程？不会。init会在它的每个子进程终止时调用wait函数取得其终止状态，这样就防止了再系统中塞满zombie进程。 8.6 wait and waitpidwait1234567#include &lt;sys/wait.h&gt;/* Wait for a child to die. When one does, put its status in *STAT_LOC and return its process ID. For errors, return (pid_t) -1. This function is a cancellation point and therefore not marked with __THROW. */extern __pid_t wait (int *__stat_loc); 对于wait来说 如果所有子进程都正在运行，则阻塞。 如该一个子进程已经终止，此时调用wait，取得子进程的terminition status立即返回。 如果它没有任何子进程，则立即出错返回。注意，对于wait，如果有多个终止状态的子进程，则wait到1个终止子进程之后直接返回。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include "mysys.h"#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdlib.h&gt;void pr_exit(int status)&#123; if(WIFEXITED(status)) printf("normal termination, exit status = %d\n", WEXITSTATUS(status)); else if(WIFSIGNALED(status)) printf("abnormal termination, signal number = %d%s\n", WTERMSIG(status),#ifdef WCOREDUMP WCOREDUMP(status) ? "(core file generated)" : "");#endif else if(WIFSTOPPED(status)) printf("child stopped, signal number = %d\n", WSTOPSIG(status));&#125;int main(int argc, char** argv)&#123; pid_t pid1; if((pid1 = fork()) &lt; 0) &#123; err_sys("Failed fork"); &#125; else if(pid1 == 0) &#123; printf("first pid: %d\n", getpid()); sleep(1); exit(7); &#125; pid_t pid2; if((pid2 = fork()) &lt; 0) &#123; err_sys("Fork failed"); &#125; else if(pid2 == 0) &#123; printf("second pid: %d\n", getpid()); sleep(2); abort(); &#125; pid_t pid3; if((pid3 = fork()) &lt; 0) &#123; err_sys("Fork failed"); &#125; else if(pid3 == 0) &#123; printf("third pid: %d\n", getpid()); sleep(2); int status = 1/ 0; &#125; // sleep(10)的目的是使这3个子进程都已经处在终止状态 sleep(10); int status; pid_t pwait; while((pwait = wait(&amp;status)) &gt; 0) &#123; printf("The waited pid is %d\n", pwait); pr_exit(status); &#125; exit(0);&#125; 运行程序的结果是123456789third pid: 4205second pid: 4204first pid: 4203The waited pid is 4203normal termination, exit status = 7The waited pid is 4204abnormal termination, signal number = 6(core file generated)The waited pid is 4205abnormal termination, signal number = 8(core file generated) waitpid1234567891011121314151617#include &lt;sys/wait.h&gt;/* Wait for a child matching PID to die. If PID is greater than 0, match any process whose process ID is PID. If PID is (pid_t) -1, match any process. If PID is (pid_t) 0, match any process with the same process group as the current process. If PID is less than -1, match any process whose process group is the absolute value of PID. If the WNOHANG bit is set in OPTIONS, and that child is not already dead, return (pid_t) 0. If successful, return PID and store the dead child's status in STAT_LOC. Return (pid_t) -1 for errors. If the WUNTRACED bit is set in OPTIONS, return status for stopped children; otherwise don't. This function is a cancellation point and therefore not marked with __THROW. */extern __pid_t waitpid (__pid_t __pid, int *__stat_loc, int __options); waitpid提供了wait没有的3个功能： waitpid可等待一个特定的进程，而wait则返回任一终止子进程的状态。 waitpid提供了1个wait的非阻塞版本。 waitpid同感WUNTRACED and WCONTINUED 选项支持作业控制。 If we want to write a process so that it forks achild but we don’t want to wait for the child to complete and we don’t want the child to become a zombie untilwe terminate, the trick is to call fork twice.以上的意思是，我们创建了1个子进程，但是我们又不想wait它。这样，当子进程终止时，就会变成zombie进程。怎么办？换句话说，就是生了不愿意养，那么就需要给子进程找一个收养着，这个收养者就是init进程。1234567891011121314151617181920212223242526272829303132333435#include "apue.h"#include "mysys.h"#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char** argv)&#123; pid_t child; if((child = fork()) &lt; 0) &#123; err_sys("failed fork"); &#125; else if(child == 0) &#123; pid_t son_child; if((son_child = fork()) &lt; 0) &#123; err_sys("fork failed"); &#125; else if(son_child &gt; 0) &#123; exit(0); &#125; sleep(2); printf("ppid:%d\n", getppid()); &#125; if(waitpid(child, NULL, 0) != child) &#123; err_sys("wait failed"); &#125; exit(0);&#125; 输出是: ppid: 1wait failed: No child processes ???????????????????为什么会出现上述的打印？ 我们将waitpid的返回值打印出来debug， 即如下的code123456789101112131415161718192021222324252627282930313233343536373839#include &quot;apue.h&quot;#include &quot;mysys.h&quot;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char** argv)&#123; pid_t child; if((child = fork()) &lt; 0) &#123; err_sys(&quot;failed fork&quot;); &#125; else if(child == 0) &#123; pid_t son_child; if((son_child = fork()) &lt; 0) &#123; err_sys(&quot;fork failed&quot;); &#125; else if(son_child &gt; 0) &#123; exit(0); &#125; sleep(2); printf(&quot;ppid:%d\n&quot;, getppid()); &#125; sleep(1); pid_t wait_pid = waitpid(child, NULL, 0); printf(&quot;waitpid:%d, actual_pid:%d\n&quot;, wait_pid, child); if(wait_pid != child) &#123; err_sys(&quot;wait failed&quot;); &#125; exit(0);&#125; 输出为12345dylanz@vbox:~/study/ueap$ ./a.out waitpid:2496, actual_pid:2496dylanz@vbox:~/study/ueap$ ppid:1waitpid:-1, actual_pid:0wait failed: No child processes 会发现wait_pid打印了两次，oh….原因是除了main process之外，son_child process也会执行waitpid的code，所以报错的打印时son_child打印的。我们需要再line28行添加exit(0).]]></content>
      <categories>
        <category>apue</category>
      </categories>
      <tags>
        <tag>apue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chap7 进程环境]]></title>
    <url>%2F2018%2F09%2F29%2Fchap7-process%2F</url>
    <content type="text"><![CDATA[7.3 进程终止1 退出函数123456#include &lt;stdlib.h&gt;void exit(int status)void _Exit(int status);#include &lt;unistd.h&gt;void _exit(int status); 如上, _Exit 与 _exit是等价的，其exit的区别是： _exit 与 _Exit直接进入内核 exit先执行一些清理工作，然后再进入内核。exit函数在执行时总是会清理关闭标准I/O库，会将缓冲区的数据输出到文件 1234567// exit// 输出Hello Worldint main(int argc, char** argv)&#123; printf("Hello World"); exit(0);&#125; 123456// _exit: 无输出int main(int argc, char** argv)&#123; printf("Hello World"); _exit(0);&#125; 在stdlib.h中，对exit的定义为 1234/* Call all functions registered with `atexit' and `on_exit', in the reverse of the order in which they were registered, perform stdio cleanup, and terminate program execution with STATUS. */extern void exit (int __status) __THROW __attribute__ ((__noreturn__)); 在调用exit时，会首先Call all the registered functions, 然后再执行cleanup, terminate program execution with STATUS. 下面我们再看看_exit的定义12/* Terminate program execution with the low-order 8 bits of STATUS. */extern void _exit (int __status) __attribute__ ((__noreturn__)); 直接Terminate program execution. 那么现在问题来了：什么时候调用exit and _exit ?再fork出的child process中需要用_exit, 不能用exit. 因为如果在child process中调用exit, 就会调用atexit中register的functions, 导致parent process的一些tempary file 丢失。 会flush stdio buffer两遍。如上的2可以理解，但是1暂不了解。。。。 12345678910switch (fork()) &#123; case 0: // we're the child execlp("some", "program", NULL); _exit(1); // &lt;-- HERE case -1: // error, no fork done ... default: // we're the parent&#125; 2. atexit 函数老规矩，我们先看在stdlib.h中对atexit的声明12/* Register a function to be called when `exit&apos; is called. */extern int atexit (void (*__func) (void)) __THROW __nonnull ((1)); 注意函数的调用顺序与登记顺序是相反的，其实也就是个 函数栈。 12345678910111213141516171819202122232425#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;static void func1();static void func2();int main(int argc, char** argv)&#123; atexit(func1); atexit(func2); printf("Hello World\n"); exit(0);&#125;void func1()&#123; printf("Call the func1\n");&#125;void func2()&#123; printf("Call the func2\n");&#125; 当进程退出时原文引用APUE的话： |The only way a program can be executed by the kernel is if one of the exec functions iscalled. The only way a process can voluntarily terminate is if _exit or _Exit is called,either explicitly or implicitly (by calling exit). A process can also be involuntarilyterminated by a signal (not shown in Figure 7.2).]]></content>
      <categories>
        <category>apue</category>
      </categories>
      <tags>
        <tag>apue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UEAP]]></title>
    <url>%2F2018%2F09%2F18%2FUEAP%2F</url>
    <content type="text"><![CDATA[Chap1 Unix基础知识1.5 输入与输出文件描述符(fd) – 用以标识一个特定的进程正在访问的文件。当内核打开1个现有文件或创建一个新文件，它都返回一个文件描述符。在读写文件时，都可以使用这个fd.每当允许一个新程序，所有的shell都为其打开3个fd: standard input, standard output, standard error.函数open, read, write, lseek, close 提供了不带缓冲的IO. 1234567891011121314151617181920212223#include &quot;apue.h&quot;#include &quot;mysys.h&quot;#define BUFFSIZE 4096int main(void)&#123; int n; char buf[BUFFSIZE]; while((n = read(STDIN_FILENO, buf, BUFFSIZE)) &gt; 0) &#123; if(write(STDOUT_FILENO, buf, n) != n) &#123; err_sys(&quot;Write error&quot;); &#125; &#125; if (n &lt; 0) &#123; err_sys(&quot;read error&quot;); &#125;&#125; 上述code都是定义在&lt;unistd.h&gt;1234567891011121314151617/* Standard file descriptors. */ #define STDIN_FILENO 0 /* Standard input. */ #define STDOUT_FILENO 1 /* Standard output. */ #define STDERR_FILENO 2 /* Standard error output. */ /* Read NBYTES into BUF from FD. Return the number read, -1 for errors or 0 for EOF. This function is a cancellation point and therefore not marked with __THROW. */extern ssize_t read (int __fd, void *__buf, size_t __nbytes) __wur;/* Write N bytes of BUF to FD. Return the number written, or -1. This function is a cancellation point and therefore not marked with __THROW. */extern ssize_t write (int __fd, const void *__buf, size_t __n) __wur; 注意1./a.out &lt; infile &gt; outfile // 会将infile内容复制到outfile 标准I/O – 带缓冲的IO 1.6 程序和进程123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &quot;apue.h&quot;#include &quot;mysys.h&quot;#include &lt;sys/wait.h&gt;int main(void)&#123; char buff[MAXLINE]; pid_t pid; printf(&quot;%% &quot;); // 当按下Ctrl+C, fgets返回NULL, 此时循环终止 // fget的每一行都以\n结尾 while(fgets(buff, MAXLINE, stdin) != NULL) &#123; if(buff[strlen(buff) - 1] == &apos;\n&apos;) &#123; // 因为execlp以NULL终止，所以这里将\n替换为NULL buff[strlen(buff) - 1] = 0; &#125; if((pid = fork()) &lt; 0) &#123; err_sys(&quot;fork failed&quot;); &#125; else if(pid == 0) // child process &#123; execlp(buff, buff, 0); err_ret(&quot;Coundn&apos;t execute: %s&quot;, buff); exit(127); &#125; /* parent */ int status; // wait for a child pid to die if((pid = waitpid(pid,&amp; status, 0)) &lt; 0) &#123; err_sys(&quot;waitpid error&quot;); &#125; printf(&quot;%% &quot;); &#125; exit(0);&#125; 1.7 出错处理errno 用于标识当前系统函数出错的情况. 123/* The error code set by various library functions. */extern int *__errno_location (void) __THROW __attribute_const__;# define errno (*__errno_location ()) 在Linux中将errno按如上定义。在多线程中，每个线程都有自己的errno，从而线程间互不影响。注意errno是全局变量。strerror – 用于打印出errno对应的错误信息perror – 在错误信息的基础上，添加当前errno的对应的出错string. 12345#include &lt;string.h&gt;char* strerror(int errnum);#include &lt;stdio.h&gt;void perror(const char* msg); // 输出为 msg + errno对应的错误string 1234567891011#include &quot;apue.h&quot;#include &lt;errno.h&gt;int main(int argc, char** argv)&#123; fprintf(stderr, &quot;EACCES: %s\n&quot;, strerror(EACCES)); errno = ENOENT; perror(argv[0]); exit(0);&#125; The error numbers are defined in errno-base.h1234567#define EPERM 1 /* Operation not permitted */#define ENOENT 2 /* No such file or directory */#define ESRCH 3 /* No such process */#define EINTR 4 /* Interrupted system call */#define EIO 5 /* I/O error */#define ENXIO 6 /* No such device or address */... Chap3 File I/O3.2 File DescriptorsTo bthe kernel, all open files are referred to by file descriptors.When we create or open a file, the kernel returns a file descriptor to the process which is used to read/write the file1234#include &lt;unistd&gt;#define STDIN_FILENO 0#define STDOUT_FILENO 1#define STDERR_FILENO 2 3.3 open and openat Functions1234#include &lt;fcntl.h&gt;int open(const char* filepath, int a flag, .../* mode_t mode */);int open(int fd, const char* filepath, int a flag, .../* mode_t mode */); The file descriptor returned by open and openat is guaranteed to be the lowest-numbered usunsed descriptor.12345678910111213141516171819202122232425262728293031#include &quot;apue.h&quot;#include &quot;mysys.h&quot;#include &lt;fcntl.h&gt;int main(void)&#123; // create a new file1. int fd = open(&quot;file1&quot;, O_RDONLY | O_WRONLY | O_CREAT | O_TRUNC, FILE_MODE); if(fd == -1) &#123; err_sys(&quot;open failed&quot;); &#125; printf(&quot;fd of file1 is %d&quot;, fd); // Get the fd of dir Debug int dirFd = open(&quot;Debug&quot;, O_DIRECTORY, DIR_MODE); if(dirFd == -1) &#123; err_sys(&quot;open dir failed&quot;); &#125; printf(&quot;dirFD: %d&quot;, dirFd); // create a new file file2 in Debug/ int fd2 = openat(dirFd, &quot;file2&quot;, O_RDONLY | O_WRONLY | O_CREAT | O_TRUNC, FILE_MODE); if(fd2 == -1) &#123; err_sys(&quot;open file2 failed&quot;); &#125; exit(0);&#125; 123#include &lt;fcntl.h&gt;// equivalent to open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);int creat(const char* path, mode_t mode); Note:通过creat创建的file，只能写(O_WRONLY). 如果想实现写的话，需要creat-&gt;close-&gt;open. 或者是1open(path, O_RDONLY | O_WRONLY | O_CREAT | O_TRUNC, mode); 123#include &lt;unistd.h&gt;int close(int fd); Note: All of its open files are closed automatically by the kernel when a process terminates. 3.6 lseek Function每个open的文件都有一个 current file offset , 文件读写都是从这个offset开始的，并且offset会增加the number of bytes read or written.lseek就是来调整这个current file offset的。注意lseek只是调整offset, 不会导致any I/O operation.123#include &lt;unistd.h&gt;off_t lseek(int fd, off_t offset, int whence); // return the new offset if OK, -1 on error 123# define SEEK_SET 0 /* Seek from beginning of file. */# define SEEK_CUR 1 /* Seek from current position. */# define SEEK_END 2 /* Seek from end of file. */ How to get the current offset:12off_t curPos;curPos = lseek(fd, 0, SEEK_CUR); 也可以将offset设置到文件的end后1234567891011121314151617181920212223242526272829303132333435363738394041#include &quot;apue.h&quot;#include &quot;mysys.h&quot;#include &lt;fcntl.h&gt;char buf1[] = &quot;abcdefg&quot;;char buf2[] = &quot;ABCDEFG&quot;;int main(void)&#123; int fd; if((fd = creat(&quot;file.hole&quot;, FILE_MODE)) &lt; 0) &#123; err_sys(&quot;creat error&quot;); &#125; if(write(fd, buf1, 7) != 7) &#123; err_sys(&quot;buf1 write error&quot;); &#125; if(lseek(fd, 16384, SEEK_SET) == -1) &#123; err_sys(&quot;seek error&quot;); &#125; if(write(fd, buf2, 7) != 7) &#123; err_sys(&quot;buf2 write error&quot;); &#125; off_t curPos = lseek(fd, 0, SEEK_CUR); if(curPos == -1) &#123; err_sys(&quot;seek cur pos error&quot;); &#125; printf(&quot;%d\n&quot;, curPos); exit(0);&#125; file.hole的内容是123456dylanz@vbox:~/study/ueap$ od -c file.hole 0000000 a b c d e f g \0 \0 \0 \0 \0 \0 \0 \0 \00000020 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0*0040000 A B C D E F G0040007 read/write Function1234#include &lt;unistd.h&gt;// return number of bytes read; 0 if end of file; -1 on errorssize_t read(int fd, void *buf, size_t nbytes); 3.10 File Sharing 如上图，包含3个部分： process table entry这个是per process的，其中包括了在这个process上打开文件的fd. Associated with each fd are: The file descriptor flags. a pointer to a file table entry. file table entry这个不是per process的。对于被不同process打开的同一文件，会有多个file table entry.其中包含了file status flag and current file offset，都是用于操作文件的。 Vnode table entry这个是真正的per file的，包含the type of the file and pointers to the functions that operate on the file. 此外，大多数files还包括inode info. 下面是2个processes打开同一文件的示意图: 注意每个process都有自己的file table entry，其实这也是可以理解的，因为file table entry中包括的是flags and offset 对与每个process很可能是不同的。当进行如下操作时： write current file offset in file table entry会增加the number of written bytes. 如果current file offset &gt; current file size in i-node, current file size也会更新为current file offset. write with O_APPEND.在每次写之前，都会将current file offset in file table entry 设置为current file size in i_node. 这样就会force every write to be appended to the current end of file. lseeklseek 只会修改current file offset in file table entry , 不会改v-node中的内容。 请注意下面的描述，不是很明白1234It is possible for more than one ﬁle descriptor entry to point to the same ﬁle tableentry, as we’ll see when we discuss the dup function in Section 3.12. This also happensafter a fork when the parent and the child share the same ﬁle table entry for each opendescriptor (Section 8.3). Note: The difference between the file descriptor flags and file status flag File descriptor flags(in file descriptor entry): Apply to a single descriptor in a single process. file status flag(in file table entry): Apply to all descriptors in any process that point to the given file table entry. 3.11 Atomic Operations Appending to a File 123456789if(lseek(fd, 0L, 2) &lt; 0)&#123; err_sys(&quot;lseek error&quot;);&#125;if(write(fd, buf. 100) != 100)&#123; err_sys(&quot;write error&quot;);&#125; 如上code， 如果有2个process同时Appending to a file, 就会发生冲突.1) process A, B 同时对file通过如上code进行append操作。此时会产生2个file table entry.2) In process A, lseek 将current file offset设置到file end. 例如到15003) In process B, lseek 将current file offset设置到file end, 为15004）In process B, write 100个byte，此时current file offset and current file size 均为1600.5）In process A, 开始write，但是此时current file offset为1500, overwrite 了B写的内容。 此外，UNIX system provides an atomic way to do this operation if we set the O_APPEND flag when a file is opened. pread and pwrite Functionspread = lseek + readpwrite = lseek + write 12345678910111213141516/* Read NBYTES into BUF from FD at the given position OFFSET without changing the file pointer. Return the number read, -1 for errors or 0 for EOF. This function is a cancellation point and therefore not marked with __THROW. */extern ssize_t pread (int __fd, void *__buf, size_t __nbytes, __off_t __offset) __wur;/* Write N bytes of BUF to FD at the given position OFFSET without changing the file pointer. Return the number written, or -1. This function is a cancellation point and therefore not marked with __THROW. */extern ssize_t pwrite (int __fd, const void *__buf, size_t __n, __off_t __offset) __wur; Creating a File]]></content>
      <categories>
        <category>apue</category>
      </categories>
      <tags>
        <tag>apue</tag>
      </tags>
  </entry>
</search>
