<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[UEAP]]></title>
    <url>%2F2018%2F09%2F18%2FUEAP%2F</url>
    <content type="text"><![CDATA[Chap1 Unix基础知识1.5 输入与输出文件描述符(fd) – 用以标识一个特定的进程正在访问的文件。当内核打开1个现有文件或创建一个新文件，它都返回一个文件描述符。在读写文件时，都可以使用这个fd.每当允许一个新程序，所有的shell都为其打开3个fd: standard input, standard output, standard error.函数open, read, write, lseek, close 提供了不带缓冲的IO. 1234567891011121314151617181920212223#include &quot;apue.h&quot;#include &quot;mysys.h&quot;#define BUFFSIZE 4096int main(void)&#123; int n; char buf[BUFFSIZE]; while((n = read(STDIN_FILENO, buf, BUFFSIZE)) &gt; 0) &#123; if(write(STDOUT_FILENO, buf, n) != n) &#123; err_sys(&quot;Write error&quot;); &#125; &#125; if (n &lt; 0) &#123; err_sys(&quot;read error&quot;); &#125;&#125; 上述code都是定义在&lt;unistd.h&gt;1234567891011121314151617/* Standard file descriptors. */ #define STDIN_FILENO 0 /* Standard input. */ #define STDOUT_FILENO 1 /* Standard output. */ #define STDERR_FILENO 2 /* Standard error output. */ /* Read NBYTES into BUF from FD. Return the number read, -1 for errors or 0 for EOF. This function is a cancellation point and therefore not marked with __THROW. */extern ssize_t read (int __fd, void *__buf, size_t __nbytes) __wur;/* Write N bytes of BUF to FD. Return the number written, or -1. This function is a cancellation point and therefore not marked with __THROW. */extern ssize_t write (int __fd, const void *__buf, size_t __n) __wur; 注意1./a.out &lt; infile &gt; outfile // 会将infile内容复制到outfile 标准I/O – 带缓冲的IO 1.6 程序和进程123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &quot;apue.h&quot;#include &quot;mysys.h&quot;#include &lt;sys/wait.h&gt;int main(void)&#123; char buff[MAXLINE]; pid_t pid; printf(&quot;%% &quot;); // 当按下Ctrl+C, fgets返回NULL, 此时循环终止 // fget的每一行都以\n结尾 while(fgets(buff, MAXLINE, stdin) != NULL) &#123; if(buff[strlen(buff) - 1] == &apos;\n&apos;) &#123; // 因为execlp以NULL终止，所以这里将\n替换为NULL buff[strlen(buff) - 1] = 0; &#125; if((pid = fork()) &lt; 0) &#123; err_sys(&quot;fork failed&quot;); &#125; else if(pid == 0) // child process &#123; execlp(buff, buff, 0); err_ret(&quot;Coundn&apos;t execute: %s&quot;, buff); exit(127); &#125; /* parent */ int status; // wait for a child pid to die if((pid = waitpid(pid,&amp; status, 0)) &lt; 0) &#123; err_sys(&quot;waitpid error&quot;); &#125; printf(&quot;%% &quot;); &#125; exit(0);&#125; 1.7 出错处理errno 用于标识当前系统函数出错的情况. 123/* The error code set by various library functions. */extern int *__errno_location (void) __THROW __attribute_const__;# define errno (*__errno_location ()) 在Linux中将errno按如上定义。在多线程中，每个线程都有自己的errno，从而线程间互不影响。注意errno是全局变量。strerror – 用于打印出errno对应的错误信息perror – 在错误信息的基础上，添加当前errno的对应的出错string. 12345#include &lt;string.h&gt;char* strerror(int errnum);#include &lt;stdio.h&gt;void perror(const char* msg); // 输出为 msg + errno对应的错误string 1234567891011#include &quot;apue.h&quot;#include &lt;errno.h&gt;int main(int argc, char** argv)&#123; fprintf(stderr, &quot;EACCES: %s\n&quot;, strerror(EACCES)); errno = ENOENT; perror(argv[0]); exit(0);&#125; The error numbers are defined in errno-base.h1234567#define EPERM 1 /* Operation not permitted */#define ENOENT 2 /* No such file or directory */#define ESRCH 3 /* No such process */#define EINTR 4 /* Interrupted system call */#define EIO 5 /* I/O error */#define ENXIO 6 /* No such device or address */...]]></content>
      <tags>
        <tag>Linux UEAP</tag>
      </tags>
  </entry>
</search>
