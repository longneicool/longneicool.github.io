<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[进程控制]]></title>
    <url>%2F2018%2F10%2F09%2F%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[8.4 fork12345#include &lt;unistd.h&gt;/* Clone the calling process, creating an exact copy. Return -1 for errors, 0 to thef new process, and the process ID of the new process to the old process. */int fork(); fork是基于当前的process new1个新的process。fork分别再child process and parent process被调用1次。在child process中，fork返回0。在parent process中，fork返回child process的pid。child process 和 parent process继续执行fork之后的code，child process会获得parent process的数据空间，堆，栈的副本。 堆，栈，数据空间的副本 12345678910111213141516171819202122232425262728293031323334353637383940#include "apue.h"#include "mysys.h"#include &lt;unistd.h&gt;int globvar = 6;char buf[] = "a write to stdcout\n";int main(int argc, char** argv)&#123; int var = 80; if(write(STDOUT_FILENO, buf, sizeof(buf) - 1) != sizeof(buf) - 1) &#123; err_sys("write error"); &#125; printf("before fork\n"); pid_t pid; pid = fork(); if(pid &lt; 0) &#123; err_sys("fork failed"); &#125; else if(pid == 0) &#123; std::cout &lt;&lt; "In Child process" &lt;&lt; std::endl; globvar++; var = 1; &#125; else &#123; std::cout &lt;&lt; "In Parent process" &lt;&lt; std::endl; sleep(2); &#125; printf("pid=%d, glob=%d, var=%d\n", (long)getpid(), globvar, var); exit(0);&#125; 如果执行 ./a.out, 输出为 123456a write to stdcoutbefore forkIn Parent processIn Child processpid=3075, glob=7, var=1pid=3074, glob=6, var=80 其中3075是child process, 3074为parent process，从上可以看出这两个process的glob 和 var不同，glob是在data段，var在栈中。再次验证了child process 和parent process拥有不同的堆栈数据空间等等 缓冲区的副本对以上的程序，如果执行./a.out &gt; temp, 则输出为123456789dylanz@vbox:~/study/ueap$ ./a.out &gt; temp.out dylanz@vbox:~/study/ueap$ cat temp.out a write to stdcoutbefore forkIn Parent processbefore forkIn Child processpid=3095, glob=7, var=1pid=3094, glob=6, var=80 before fork被打印了两次，why？因为输出到文件中时，执行的是全缓冲。当执行到printf \n时，并不会flush 缓冲区，而是继续将数据保存再缓冲区中。当fork时，child process也会得到缓冲区的副本，从而会打印两次。而再命令行操作时，执行的时行缓冲，数据再printf \n时，缓冲区就已经被flush了。 | 全缓冲 指系统再填满标准IO缓冲区之后才进行实际的IO操作。对于驻留再磁盘上的文件来说通常是由标准IO实现的全缓冲 行缓冲 标准IO再输入和输出中遇到换行符时执行I/O操作。当流涉及到终端时，通常使用的是行缓冲 无缓冲 标准出错流stderr通常时无缓冲的 文件共享看如下的code，会输出啥？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;unistd.h&gt;#include "apue.h"#include "mysys.h"#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;void write_str(bool is_child, int fd)&#123; const char child_buf[] = "I am in child process"; const char parent_buf[] = "I am in parent process"; const char* buf = is_child ? child_buf : parent_buf; int len = write(fd, buf, strlen(buf) - 1); if(len != strlen(buf) - 1) &#123; err_sys("Failed to write data in child process"); &#125; int cur_pos = lseek(fd, 0, SEEK_CUR); printf("Current pos is %d\n", cur_pos);&#125;int main(int argc, char** argv)&#123; int fd = creat("fork.txt", FILE_MODE); if(fd &lt; 0) &#123; err_sys("Failed to creat the file fork.txt"); &#125; pid_t child_pid = fork(); if(child_pid &lt; 0) &#123; err_sys("failed to fork"); &#125; else if(child_pid == 0) // in child process &#123; write_str(true, fd); &#125; else &#123; sleep(2); write_str(false, fd); &#125;&#125; 再fork.txt中的内容为：I am in child procesI am in parent proces可以看到其中的string没有重叠部分，parent process的写入内容在child process之后。这说明了啥？以上说明了parent process与child process共享同一文件偏移量。实际上，fork的一个特性就是parent process的所有打开的file descriptor都会被复制到child process中，等价与执行了dup 函数。 总结fork有以下两种用法： 1个parent process希望复制自己，使parent process and child process同时执行不同的代码段。这在网络服务中非常常见，—parent process等待客户端的服务请求，当这种请求到达时，parent process调用fork，使得child process处理此请求。parent process则继续等待下一个服务请求 一个进程要执行一个不同的程序，在这种情况下，child process从fork返回后，立即调用exec… 8.5 函数exit本节主要介绍再进程退出时父进程与子进程的关系。进程有5种正常和3种异常终止方式，5种正常终止方式有： 在main中return 2. 调用exit 3. 调用_exit 4. 进程的最后1个线程再其启动例程中执行return语句。但是该线程的返回值不作为进程的返回值。此时进程的终止状态为0 5. 进程的最后1个线程调用pthread_exit，但是进程的终止状态依然为0. 异常终止状态有：1) 调用abort 2) 进程收到某些信息 3) 最后一个线程对cancellation请求作出响应。 无论对于那一种退出方式，我们都希望终止进程能够通知其父进程它是如何终止的对于正常终止来说，终止进程将其exit status作为参数传到exit或_exit函数中，然后再转换为termination status对于异常终止来说，内核会产生一个指示其异常终止原因的termination status。无论以上那种情况，该终止进程的父进程都能用wait或waitpid函数取得其终止状态。123456/* Wait for a child to die. When one does, put its status in *STAT_LOC and return its process ID. For errors, return (pid_t) -1. This function is a cancellation point and therefore not marked with __THROW. */extern __pid_t wait (int *__stat_loc); 1234567891011121314151617181920212223242526272829303132333435#include "apue.h"#include "mysys.h"#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdlib.h&gt;void pr_exit(int status)&#123; if(WIFEXITED(status)) printf("normal termination, exit status = %d\n", WEXITSTATUS(status)); else if(WIFSIGNALED(status)) printf("abnormal termination, signal number = %d%s\n", WTERMSIG(status),#ifdef WCOREDUMP WCOREDUMP(status) ? "(core file generated)" : "");#endif else if(WIFSTOPPED(status)) printf("child stopped, signal number = %d\n", WSTOPSIG(status));&#125;int main(int argc, char** argv)&#123; pid_t child = fork(); if(child &lt; 0) &#123; err_sys("fork failed"); &#125; else if(child == 0) &#123; int a = 1 / 0; &#125; int status; pid_t p = wait(&amp;status); pr_exit(status);&#125; 输出为： abnormal termination, signal number = 8(core file generated) 下面我们就讨论子进程与父进程的终止关系 子进程在父进程之前终止 1) 如果是正常终止，则将其exit status作为参数传递给exit函数 2) 如果是异常终止，内核会为每个终止的紫禁城保存一定量的信息，父进程可以同感wait函数调用 父进程再子进程之前终止对于父进程已经终止的所有进程，他们的父进程都改变为init进程，即这些进程被init进程收养。其大概操作步骤是：当一个进程终止时，内核会检查其是否还有子进程，如果有，则将这些子进程的父进程全部改为init进程，从而保证每个进程有1个父进程。 12345678910111213141516171819202122232425262728#include "apue.h"#include "mysys.h"#include &lt;unistd.h&gt;int main(int argc, char** argv)&#123; pid_t child = fork(); if(child &lt; 0) &#123; err_sys("Failed to fork"); &#125; else if(child == 0) &#123; int n = 0; while(n &lt; 100) &#123; sleep(1); printf("ppid:%d\n", getppid()); n++; &#125; &#125; else &#123; sleep(2); &#125; return 0;&#125; 以上程序的输出是ppid:2688ppid:1ppid:1ppid:1ppid:1ppid:1ppid:1ppid:1ppid:1ppid:1 如上可见，在2s后，父进程退出后，child进程的父进程会改为init进程(pid为1).zombie进程 – 对于一个已经终止，但是其父进程尚未对其进行善后处理（获取终止子进程的有关信息，释放它仍占用的资源）的进程成为zombie进程。 由init进程收养的进程终止时，会不会变成zombie 进程？不会。init会在它的每个子进程终止时调用wait函数取得其终止状态，这样就防止了再系统中塞满zombie进程。 8.6 wait and waitpidwait1234567#include &lt;sys/wait.h&gt;/* Wait for a child to die. When one does, put its status in *STAT_LOC and return its process ID. For errors, return (pid_t) -1. This function is a cancellation point and therefore not marked with __THROW. */extern __pid_t wait (int *__stat_loc); 对于wait来说 如果所有子进程都正在运行，则阻塞。 如该一个子进程已经终止，此时调用wait，取得子进程的terminition status立即返回。 如果它没有任何子进程，则立即出错返回。注意，对于wait，如果有多个终止状态的子进程，则wait到1个终止子进程之后直接返回。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include "mysys.h"#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdlib.h&gt;void pr_exit(int status)&#123; if(WIFEXITED(status)) printf("normal termination, exit status = %d\n", WEXITSTATUS(status)); else if(WIFSIGNALED(status)) printf("abnormal termination, signal number = %d%s\n", WTERMSIG(status),#ifdef WCOREDUMP WCOREDUMP(status) ? "(core file generated)" : "");#endif else if(WIFSTOPPED(status)) printf("child stopped, signal number = %d\n", WSTOPSIG(status));&#125;int main(int argc, char** argv)&#123; pid_t pid1; if((pid1 = fork()) &lt; 0) &#123; err_sys("Failed fork"); &#125; else if(pid1 == 0) &#123; printf("first pid: %d\n", getpid()); sleep(1); exit(7); &#125; pid_t pid2; if((pid2 = fork()) &lt; 0) &#123; err_sys("Fork failed"); &#125; else if(pid2 == 0) &#123; printf("second pid: %d\n", getpid()); sleep(2); abort(); &#125; pid_t pid3; if((pid3 = fork()) &lt; 0) &#123; err_sys("Fork failed"); &#125; else if(pid3 == 0) &#123; printf("third pid: %d\n", getpid()); sleep(2); int status = 1/ 0; &#125; // sleep(10)的目的是使这3个子进程都已经处在终止状态 sleep(10); int status; pid_t pwait; while((pwait = wait(&amp;status)) &gt; 0) &#123; printf("The waited pid is %d\n", pwait); pr_exit(status); &#125; exit(0);&#125; 运行程序的结果是123456789third pid: 4205second pid: 4204first pid: 4203The waited pid is 4203normal termination, exit status = 7The waited pid is 4204abnormal termination, signal number = 6(core file generated)The waited pid is 4205abnormal termination, signal number = 8(core file generated) waitpid1234567891011121314151617#include &lt;sys/wait.h&gt;/* Wait for a child matching PID to die. If PID is greater than 0, match any process whose process ID is PID. If PID is (pid_t) -1, match any process. If PID is (pid_t) 0, match any process with the same process group as the current process. If PID is less than -1, match any process whose process group is the absolute value of PID. If the WNOHANG bit is set in OPTIONS, and that child is not already dead, return (pid_t) 0. If successful, return PID and store the dead child's status in STAT_LOC. Return (pid_t) -1 for errors. If the WUNTRACED bit is set in OPTIONS, return status for stopped children; otherwise don't. This function is a cancellation point and therefore not marked with __THROW. */extern __pid_t waitpid (__pid_t __pid, int *__stat_loc, int __options); waitpid提供了wait没有的3个功能： waitpid可等待一个特定的进程，而wait则返回任一终止子进程的状态。 waitpid提供了1个wait的非阻塞版本。 waitpid同感WUNTRACED and WCONTINUED 选项支持作业控制。 If we want to write a process so that it forks achild but we don’t want to wait for the child to complete and we don’t want the child to become a zombie untilwe terminate, the trick is to call fork twice.以上的意思是，我们创建了1个子进程，但是我们又不想wait它。这样，当子进程终止时，就会变成zombie进程。怎么办？换句话说，就是生了不愿意养，那么就需要给子进程找一个收养着，这个收养者就是init进程。1234567891011121314151617181920212223242526272829303132333435#include "apue.h"#include "mysys.h"#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char** argv)&#123; pid_t child; if((child = fork()) &lt; 0) &#123; err_sys("failed fork"); &#125; else if(child == 0) &#123; pid_t son_child; if((son_child = fork()) &lt; 0) &#123; err_sys("fork failed"); &#125; else if(son_child &gt; 0) &#123; exit(0); &#125; sleep(2); printf("ppid:%d\n", getppid()); &#125; if(waitpid(child, NULL, 0) != child) &#123; err_sys("wait failed"); &#125; exit(0);&#125; 输出是: ppid: 1wait failed: No child processes ???????????????????为什么会出现上述的打印？ 我们将waitpid的返回值打印出来debug， 即如下的code123456789101112131415161718192021222324252627282930313233343536373839#include &quot;apue.h&quot;#include &quot;mysys.h&quot;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char** argv)&#123; pid_t child; if((child = fork()) &lt; 0) &#123; err_sys(&quot;failed fork&quot;); &#125; else if(child == 0) &#123; pid_t son_child; if((son_child = fork()) &lt; 0) &#123; err_sys(&quot;fork failed&quot;); &#125; else if(son_child &gt; 0) &#123; exit(0); &#125; sleep(2); printf(&quot;ppid:%d\n&quot;, getppid()); &#125; sleep(1); pid_t wait_pid = waitpid(child, NULL, 0); printf(&quot;waitpid:%d, actual_pid:%d\n&quot;, wait_pid, child); if(wait_pid != child) &#123; err_sys(&quot;wait failed&quot;); &#125; exit(0);&#125; 输出为12345dylanz@vbox:~/study/ueap$ ./a.out waitpid:2496, actual_pid:2496dylanz@vbox:~/study/ueap$ ppid:1waitpid:-1, actual_pid:0wait failed: No child processes 会发现wait_pid打印了两次，oh….原因是除了main process之外，son_child process也会执行waitpid的code，所以报错的打印时son_child打印的。我们需要再line28行添加exit(0).]]></content>
      <tags>
        <tag>APUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chap7 进程环境]]></title>
    <url>%2F2018%2F09%2F29%2Fchap7-process%2F</url>
    <content type="text"><![CDATA[7.3 进程终止1 退出函数123456#include &lt;stdlib.h&gt;void exit(int status)void _Exit(int status);#include &lt;unistd.h&gt;void _exit(int status); 如上, _Exit 与 _exit是等价的，其exit的区别是： _exit 与 _Exit直接进入内核 exit先执行一些清理工作，然后再进入内核。exit函数在执行时总是会清理关闭标准I/O库，会将缓冲区的数据输出到文件 1234567// exit// 输出Hello Worldint main(int argc, char** argv)&#123; printf("Hello World"); exit(0);&#125; 123456// _exit: 无输出int main(int argc, char** argv)&#123; printf("Hello World"); _exit(0);&#125; 在stdlib.h中，对exit的定义为 1234/* Call all functions registered with `atexit' and `on_exit', in the reverse of the order in which they were registered, perform stdio cleanup, and terminate program execution with STATUS. */extern void exit (int __status) __THROW __attribute__ ((__noreturn__)); 在调用exit时，会首先Call all the registered functions, 然后再执行cleanup, terminate program execution with STATUS. 下面我们再看看_exit的定义12/* Terminate program execution with the low-order 8 bits of STATUS. */extern void _exit (int __status) __attribute__ ((__noreturn__)); 直接Terminate program execution. 那么现在问题来了：什么时候调用exit and _exit ?再fork出的child process中需要用_exit, 不能用exit. 因为如果在child process中调用exit, 就会调用atexit中register的functions, 导致parent process的一些tempary file 丢失。 会flush stdio buffer两遍。如上的2可以理解，但是1暂不了解。。。。 12345678910switch (fork()) &#123; case 0: // we're the child execlp("some", "program", NULL); _exit(1); // &lt;-- HERE case -1: // error, no fork done ... default: // we're the parent&#125; 2. atexit 函数老规矩，我们先看在stdlib.h中对atexit的声明12/* Register a function to be called when `exit&apos; is called. */extern int atexit (void (*__func) (void)) __THROW __nonnull ((1)); 注意函数的调用顺序与登记顺序是相反的，其实也就是个 函数栈。 12345678910111213141516171819202122232425#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;static void func1();static void func2();int main(int argc, char** argv)&#123; atexit(func1); atexit(func2); printf("Hello World\n"); exit(0);&#125;void func1()&#123; printf("Call the func1\n");&#125;void func2()&#123; printf("Call the func2\n");&#125; 当进程退出时原文引用APUE的话： |The only way a program can be executed by the kernel is if one of the exec functions iscalled. The only way a process can voluntarily terminate is if _exit or _Exit is called,either explicitly or implicitly (by calling exit). A process can also be involuntarilyterminated by a signal (not shown in Figure 7.2).]]></content>
      <tags>
        <tag>apue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UEAP]]></title>
    <url>%2F2018%2F09%2F18%2FUEAP%2F</url>
    <content type="text"><![CDATA[Chap1 Unix基础知识1.5 输入与输出文件描述符(fd) – 用以标识一个特定的进程正在访问的文件。当内核打开1个现有文件或创建一个新文件，它都返回一个文件描述符。在读写文件时，都可以使用这个fd.每当允许一个新程序，所有的shell都为其打开3个fd: standard input, standard output, standard error.函数open, read, write, lseek, close 提供了不带缓冲的IO. 1234567891011121314151617181920212223#include &quot;apue.h&quot;#include &quot;mysys.h&quot;#define BUFFSIZE 4096int main(void)&#123; int n; char buf[BUFFSIZE]; while((n = read(STDIN_FILENO, buf, BUFFSIZE)) &gt; 0) &#123; if(write(STDOUT_FILENO, buf, n) != n) &#123; err_sys(&quot;Write error&quot;); &#125; &#125; if (n &lt; 0) &#123; err_sys(&quot;read error&quot;); &#125;&#125; 上述code都是定义在&lt;unistd.h&gt;1234567891011121314151617/* Standard file descriptors. */ #define STDIN_FILENO 0 /* Standard input. */ #define STDOUT_FILENO 1 /* Standard output. */ #define STDERR_FILENO 2 /* Standard error output. */ /* Read NBYTES into BUF from FD. Return the number read, -1 for errors or 0 for EOF. This function is a cancellation point and therefore not marked with __THROW. */extern ssize_t read (int __fd, void *__buf, size_t __nbytes) __wur;/* Write N bytes of BUF to FD. Return the number written, or -1. This function is a cancellation point and therefore not marked with __THROW. */extern ssize_t write (int __fd, const void *__buf, size_t __n) __wur; 注意1./a.out &lt; infile &gt; outfile // 会将infile内容复制到outfile 标准I/O – 带缓冲的IO 1.6 程序和进程123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &quot;apue.h&quot;#include &quot;mysys.h&quot;#include &lt;sys/wait.h&gt;int main(void)&#123; char buff[MAXLINE]; pid_t pid; printf(&quot;%% &quot;); // 当按下Ctrl+C, fgets返回NULL, 此时循环终止 // fget的每一行都以\n结尾 while(fgets(buff, MAXLINE, stdin) != NULL) &#123; if(buff[strlen(buff) - 1] == &apos;\n&apos;) &#123; // 因为execlp以NULL终止，所以这里将\n替换为NULL buff[strlen(buff) - 1] = 0; &#125; if((pid = fork()) &lt; 0) &#123; err_sys(&quot;fork failed&quot;); &#125; else if(pid == 0) // child process &#123; execlp(buff, buff, 0); err_ret(&quot;Coundn&apos;t execute: %s&quot;, buff); exit(127); &#125; /* parent */ int status; // wait for a child pid to die if((pid = waitpid(pid,&amp; status, 0)) &lt; 0) &#123; err_sys(&quot;waitpid error&quot;); &#125; printf(&quot;%% &quot;); &#125; exit(0);&#125; 1.7 出错处理errno 用于标识当前系统函数出错的情况. 123/* The error code set by various library functions. */extern int *__errno_location (void) __THROW __attribute_const__;# define errno (*__errno_location ()) 在Linux中将errno按如上定义。在多线程中，每个线程都有自己的errno，从而线程间互不影响。注意errno是全局变量。strerror – 用于打印出errno对应的错误信息perror – 在错误信息的基础上，添加当前errno的对应的出错string. 12345#include &lt;string.h&gt;char* strerror(int errnum);#include &lt;stdio.h&gt;void perror(const char* msg); // 输出为 msg + errno对应的错误string 1234567891011#include &quot;apue.h&quot;#include &lt;errno.h&gt;int main(int argc, char** argv)&#123; fprintf(stderr, &quot;EACCES: %s\n&quot;, strerror(EACCES)); errno = ENOENT; perror(argv[0]); exit(0);&#125; The error numbers are defined in errno-base.h1234567#define EPERM 1 /* Operation not permitted */#define ENOENT 2 /* No such file or directory */#define ESRCH 3 /* No such process */#define EINTR 4 /* Interrupted system call */#define EIO 5 /* I/O error */#define ENXIO 6 /* No such device or address */... Chap3 File I/O3.2 File DescriptorsTo bthe kernel, all open files are referred to by file descriptors.When we create or open a file, the kernel returns a file descriptor to the process which is used to read/write the file1234#include &lt;unistd&gt;#define STDIN_FILENO 0#define STDOUT_FILENO 1#define STDERR_FILENO 2 3.3 open and openat Functions1234#include &lt;fcntl.h&gt;int open(const char* filepath, int a flag, .../* mode_t mode */);int open(int fd, const char* filepath, int a flag, .../* mode_t mode */); The file descriptor returned by open and openat is guaranteed to be the lowest-numbered usunsed descriptor.12345678910111213141516171819202122232425262728293031#include &quot;apue.h&quot;#include &quot;mysys.h&quot;#include &lt;fcntl.h&gt;int main(void)&#123; // create a new file1. int fd = open(&quot;file1&quot;, O_RDONLY | O_WRONLY | O_CREAT | O_TRUNC, FILE_MODE); if(fd == -1) &#123; err_sys(&quot;open failed&quot;); &#125; printf(&quot;fd of file1 is %d&quot;, fd); // Get the fd of dir Debug int dirFd = open(&quot;Debug&quot;, O_DIRECTORY, DIR_MODE); if(dirFd == -1) &#123; err_sys(&quot;open dir failed&quot;); &#125; printf(&quot;dirFD: %d&quot;, dirFd); // create a new file file2 in Debug/ int fd2 = openat(dirFd, &quot;file2&quot;, O_RDONLY | O_WRONLY | O_CREAT | O_TRUNC, FILE_MODE); if(fd2 == -1) &#123; err_sys(&quot;open file2 failed&quot;); &#125; exit(0);&#125; 123#include &lt;fcntl.h&gt;// equivalent to open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);int creat(const char* path, mode_t mode); Note:通过creat创建的file，只能写(O_WRONLY). 如果想实现写的话，需要creat-&gt;close-&gt;open. 或者是1open(path, O_RDONLY | O_WRONLY | O_CREAT | O_TRUNC, mode); 123#include &lt;unistd.h&gt;int close(int fd); Note: All of its open files are closed automatically by the kernel when a process terminates. 3.6 lseek Function每个open的文件都有一个 current file offset , 文件读写都是从这个offset开始的，并且offset会增加the number of bytes read or written.lseek就是来调整这个current file offset的。注意lseek只是调整offset, 不会导致any I/O operation.123#include &lt;unistd.h&gt;off_t lseek(int fd, off_t offset, int whence); // return the new offset if OK, -1 on error 123# define SEEK_SET 0 /* Seek from beginning of file. */# define SEEK_CUR 1 /* Seek from current position. */# define SEEK_END 2 /* Seek from end of file. */ How to get the current offset:12off_t curPos;curPos = lseek(fd, 0, SEEK_CUR); 也可以将offset设置到文件的end后1234567891011121314151617181920212223242526272829303132333435363738394041#include &quot;apue.h&quot;#include &quot;mysys.h&quot;#include &lt;fcntl.h&gt;char buf1[] = &quot;abcdefg&quot;;char buf2[] = &quot;ABCDEFG&quot;;int main(void)&#123; int fd; if((fd = creat(&quot;file.hole&quot;, FILE_MODE)) &lt; 0) &#123; err_sys(&quot;creat error&quot;); &#125; if(write(fd, buf1, 7) != 7) &#123; err_sys(&quot;buf1 write error&quot;); &#125; if(lseek(fd, 16384, SEEK_SET) == -1) &#123; err_sys(&quot;seek error&quot;); &#125; if(write(fd, buf2, 7) != 7) &#123; err_sys(&quot;buf2 write error&quot;); &#125; off_t curPos = lseek(fd, 0, SEEK_CUR); if(curPos == -1) &#123; err_sys(&quot;seek cur pos error&quot;); &#125; printf(&quot;%d\n&quot;, curPos); exit(0);&#125; file.hole的内容是123456dylanz@vbox:~/study/ueap$ od -c file.hole 0000000 a b c d e f g \0 \0 \0 \0 \0 \0 \0 \0 \00000020 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0*0040000 A B C D E F G0040007 read/write Function1234#include &lt;unistd.h&gt;// return number of bytes read; 0 if end of file; -1 on errorssize_t read(int fd, void *buf, size_t nbytes); 3.10 File Sharing 如上图，包含3个部分： process table entry这个是per process的，其中包括了在这个process上打开文件的fd. Associated with each fd are: The file descriptor flags. a pointer to a file table entry. file table entry这个不是per process的。对于被不同process打开的同一文件，会有多个file table entry.其中包含了file status flag and current file offset，都是用于操作文件的。 Vnode table entry这个是真正的per file的，包含the type of the file and pointers to the functions that operate on the file. 此外，大多数files还包括inode info. 下面是2个processes打开同一文件的示意图: 注意每个process都有自己的file table entry，其实这也是可以理解的，因为file table entry中包括的是flags and offset 对与每个process很可能是不同的。当进行如下操作时： write current file offset in file table entry会增加the number of written bytes. 如果current file offset &gt; current file size in i-node, current file size也会更新为current file offset. write with O_APPEND.在每次写之前，都会将current file offset in file table entry 设置为current file size in i_node. 这样就会force every write to be appended to the current end of file. lseeklseek 只会修改current file offset in file table entry , 不会改v-node中的内容。 请注意下面的描述，不是很明白1234It is possible for more than one ﬁle descriptor entry to point to the same ﬁle tableentry, as we’ll see when we discuss the dup function in Section 3.12. This also happensafter a fork when the parent and the child share the same ﬁle table entry for each opendescriptor (Section 8.3). Note: The difference between the file descriptor flags and file status flag File descriptor flags(in file descriptor entry): Apply to a single descriptor in a single process. file status flag(in file table entry): Apply to all descriptors in any process that point to the given file table entry. 3.11 Atomic Operations Appending to a File 123456789if(lseek(fd, 0L, 2) &lt; 0)&#123; err_sys(&quot;lseek error&quot;);&#125;if(write(fd, buf. 100) != 100)&#123; err_sys(&quot;write error&quot;);&#125; 如上code， 如果有2个process同时Appending to a file, 就会发生冲突.1) process A, B 同时对file通过如上code进行append操作。此时会产生2个file table entry.2) In process A, lseek 将current file offset设置到file end. 例如到15003) In process B, lseek 将current file offset设置到file end, 为15004）In process B, write 100个byte，此时current file offset and current file size 均为1600.5）In process A, 开始write，但是此时current file offset为1500, overwrite 了B写的内容。 此外，UNIX system provides an atomic way to do this operation if we set the O_APPEND flag when a file is opened. pread and pwrite Functionspread = lseek + readpwrite = lseek + write 12345678910111213141516/* Read NBYTES into BUF from FD at the given position OFFSET without changing the file pointer. Return the number read, -1 for errors or 0 for EOF. This function is a cancellation point and therefore not marked with __THROW. */extern ssize_t pread (int __fd, void *__buf, size_t __nbytes, __off_t __offset) __wur;/* Write N bytes of BUF to FD at the given position OFFSET without changing the file pointer. Return the number written, or -1. This function is a cancellation point and therefore not marked with __THROW. */extern ssize_t pwrite (int __fd, const void *__buf, size_t __n, __off_t __offset) __wur; Creating a File]]></content>
      <tags>
        <tag>Linux UEAP</tag>
      </tags>
  </entry>
</search>
